<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="manifest" href="manifest.json" />
<link rel="apple-touch-icon" href="icon-192.png">
<meta name="theme-color" content="#1e1e1e" />
<title>Khon's Chess</title>
<style>
body {
  background-color: #1e1e1e;
  color: #fff;
  font-family: 'Courier New', Courier, monospace;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 10px;
  margin: 0;
  min-height: 100vh;
}

.logo-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 10px;
}

#logoImage {
  max-width: 180px;
  width: 80vw;
  height: auto;
  border: 2px solid #fff;
  border-radius: 12px;
}

#qrOverlay {
  display: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.6);
  color: #fff;
  font-size: 1.5em;
  font-weight: bold;
  justify-content: center;
  align-items: center;
  text-align: center;
  border-radius: 12px;
}

#chessboard {
  display: grid;
  width: 90vw;
  max-width: 480px;
  grid-template-columns: repeat(8, 1fr);
  aspect-ratio: 1 / 1;
  border: 4px solid #fff;
}

.square {
  position: relative;
  width: 100%;
  aspect-ratio: 1 / 1;
  overflow: hidden;
}

.square img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none;
}

.white {
  background-color: #eee;
  color: #000;
}

.black {
  background-color: #444;
  color: #fff;
}

.selected {
  outline: 3px solid yellow;
}

.highlight {
  background-color: #66ff6655;
}

.in-check {
  background-color: #ff000055 !important;
  box-shadow: inset 0 0 10px #ff0000;
}

.board-wrapper {
  position: relative;
  display: inline-block;
}

.rank-label, .file-label {
  font-size: 0.7em;
  pointer-events: none;
  user-select: none;
  z-index: 2;
  position: absolute;
  background: none;
}

.rank-label {
  top: 2px;
  left: 2px;
}

.file-label {
  bottom: 2px;
  right: 2px;
}

.bg-selected {
  outline: 3px solid yellow;
}

.bg-highlight {
  box-shadow: inset 0 0 0 3px lime;
}

.status-bar {
  margin: 10px 0;
  padding: 8px 16px;
  background: #333;
  border-radius: 6px;
  font-size: 1.1em;
  color: #0f0;
  border: 1px solid #0f0;
}
</style>
</head>
<body>

<div class="logo-wrapper">
  <div id="logoContainer" onclick="toggleQR()" style="position: relative; display: inline-block;">
    <img id="logoImage" src="./kclogo.png" alt="Khons Chess logo" class="logo">
    <div id="qrOverlay" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.6); color: #fff; font-size: 2em; font-weight: bold; justify-content: center; align-items: center;">Share</div>
  </div>

  <div style="margin: 10px;">
    <label for="themeSelect">Theme:</label>
    <select id="themeSelect" onchange="changeTheme(this.value)">
      <option value="classic">Classic</option>
      <option value="firefly">Firefly</option>
      <option value="starwars">StarWars</option>
      <option value="startrek">StarTrek</option>
      <option value="300">300</option>
      <option value="dracula">Dracula vs V. Hunter</option>
      <option value="SamvsVik">Samurai vs Vikings</option>
      <option value="Dinos">Dinos vs Dino-Ghosts</option>
      <option value="SFIFF">SFIFF</option>
    </select>
  </div>

  <div id="statusBar" class="status-bar">White to move</div>

  <div id="chessboard"></div>

  <div id="backgammonControls" style="display:none; margin-top:10px;">
    <button id="rollDiceBtn" style="padding:6px 12px; font-size:1em;">üé≤ Roll Dice</button>
    <button id="endTurnBtn" style="padding:6px 12px; font-size:1em;">‚è≠Ô∏è End Turn</button>
    <div id="diceDisplay" style="margin-top:6px; font-size:1.2em; color:#0f0;"></div>
  </div>

  <div id="moveLog" style="
    margin-top: 75px;
    width: 90vw;
    max-width: 480px;
    background: #222;
    color: #0f0;
    font-family: monospace;
    font-size: 0.95em;
    padding: 16px;
    border-radius: 8px;
    max-height: 160px;
    overflow-y: auto;
    line-height: 1.6;
    box-shadow: 0 0 5px #0f0;
    scroll-behavior: smooth;
  ">
    <strong>Move Log:</strong><br>
  </div>

  <div style="margin-top: 10px;">
    <button onclick="downloadPGN()" style="padding: 6px 12px; font-size: 1em; font-family: monospace; border-radius: 6px; background: #333; color: #0f0; border: 1px solid #0f0;">
      ‚¨áÔ∏è Download PGN
    </button>
  </div>

  <div style="margin-top: 10px;">
    <button onclick="resetGame()" style="padding: 6px 12px; font-size: 1em; font-family: monospace; border-radius: 6px; background: #900; color: #fff; border: 1px solid #f00;">
      üîÅ Reset Game
    </button>

    <label for="gameSelect">Game:</label>
    <select id="gameSelect">
      <option value="chess">Chess</option>
      <option value="checkers">Checkers</option>
      <option value="backgammon">Backgammon</option>
    </select>
  </div>
</div>

<script>
const board = document.getElementById('chessboard');

let gameState = Array(8).fill(null).map(() => Array(8).fill(null));
const backRow = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
let selectedSquare = null;
let currentPlayer = 'white';
let legalMoves = [];
let moveHistory = [];
let castlingRights = {
  white: { K: true, Q: true },
  black: { K: true, Q: true }
};
let enPassantTarget = null;
let pgnMoves = [];
let currentTheme = 'classic';
let currentGame = 'chess';

let diceRoll = [];
let diceUsed = [];
let selectedPoint = null;
let bar = { white: 0, black: 0 };
let borneOff = { white: 0, black: 0 };

let gameResult = "*";
let halfMoveClock = 0;
let fullMoveNumber = 1;

function getSaveKey() {
  return `khonsChessSave_${currentGame}`;
}

function setURLParam(key, value) {
  const url = new URL(window.location.href);
  url.searchParams.set(key, value);

  // remove any old shorthand keys like ?SFIFF
  for (const k of Array.from(url.searchParams.keys())) {
    if (k && k.toLowerCase() !== 'theme' && k.toLowerCase() !== 'game' && url.searchParams.get(k) === '') {
      url.searchParams.delete(k);
    }
  }

  history.replaceState({}, '', url.toString());
}

function getThemeFromURL() {
  const params = new URLSearchParams(window.location.search);

  // Preferred: ?theme=SFIFF
  let t = params.get('theme');

  // Shorthand support: ?SFIFF
  if (!t) {
    for (const key of params.keys()) {
      if (!key) continue;
      const lower = key.toLowerCase();
      if (lower !== 'theme' && lower !== 'game') {
        t = key;
        break;
      }
    }
  }

  return (t || '').trim();
}

function getGameFromURL() {
  const params = new URLSearchParams(window.location.search);
  const g = (params.get('game') || '').trim();
  return g;
}

function applyThemeFromURL() {
  const requested = getThemeFromURL();
  if (!requested) return;

  const select = document.getElementById('themeSelect');
  if (!select) return;

  const match = Array.from(select.options).find(o => o.value.toLowerCase() === requested.toLowerCase());
  if (!match) return;

  currentTheme = match.value;
  select.value = match.value;
}

function applyGameFromURL() {
  const requested = getGameFromURL();
  if (!requested) return;

  const select = document.getElementById('gameSelect');
  if (!select) return;

  const match = Array.from(select.options).find(o => o.value.toLowerCase() === requested.toLowerCase());
  if (!match) return;

  currentGame = match.value;
  select.value = match.value;
}

function setupBoard() {
  gameState = Array(8).fill(null).map(() => Array(8).fill(null));
  for (let col = 0; col < 8; col++) {
    gameState[0][col] = { type: backRow[col], color: 'black', hasMoved: false };
    gameState[1][col] = { type: 'P', color: 'black', hasMoved: false };
    gameState[6][col] = { type: 'P', color: 'white', hasMoved: false };
    gameState[7][col] = { type: backRow[col], color: 'white', hasMoved: false };
  }
}

function setupCheckersBoard() {
  gameState = Array(8).fill(null).map(() => Array(8).fill(null));
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 8; col++) {
      if ((row + col) % 2 === 1) gameState[row][col] = { color: 'black' };
    }
  }
  for (let row = 5; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if ((row + col) % 2 === 1) gameState[row][col] = { color: 'white' };
    }
  }
}

function setupBackgammonBoard() {
  gameState = Array(24).fill(null).map(() => ({ white: 0, black: 0 }));

  // standard-ish setup
  gameState[0].black = 2;
  gameState[11].black = 5;
  gameState[16].black = 3;
  gameState[18].black = 5;

  gameState[23].white = 2;
  gameState[12].white = 5;
  gameState[7].white = 3;
  gameState[5].white = 5;

  bar = { white: 0, black: 0 };
  borneOff = { white: 0, black: 0 };
  diceRoll = [];
  diceUsed = [];
  selectedPoint = null;
}

function hardResetForCurrentGame() {
  selectedSquare = null;
  legalMoves = [];
  moveHistory = [];
  pgnMoves = [];
  currentPlayer = 'white';
  enPassantTarget = null;
  gameResult = "*";
  halfMoveClock = 0;
  fullMoveNumber = 1;

  castlingRights = {
    white: { K: true, Q: true },
    black: { K: true, Q: true }
  };

  if (currentGame === 'chess') setupBoard();
  if (currentGame === 'checkers') setupCheckersBoard();
  if (currentGame === 'backgammon') setupBackgammonBoard();

  drawBoard();
  updateStatusBar();
  saveGame();
}

function saveGame() {
  const saveData = {
    currentGame,
    currentTheme,
    gameState,
    moveHistory,
    pgnMoves,
    currentPlayer,
    castlingRights,
    enPassantTarget,
    gameResult,
    halfMoveClock,
    fullMoveNumber,
    // backgammon extras
    bar,
    borneOff,
    diceRoll,
    diceUsed,
    selectedPoint
  };
  localStorage.setItem(getSaveKey(), JSON.stringify(saveData));
}

function loadGame() {
  const saved = localStorage.getItem(getSaveKey());
  if (saved) {
    const data = JSON.parse(saved);

    gameState = data.gameState || gameState;
    moveHistory = data.moveHistory || [];
    pgnMoves = data.pgnMoves || [];
    currentPlayer = data.currentPlayer || 'white';
    castlingRights = data.castlingRights || castlingRights;
    enPassantTarget = data.enPassantTarget || null;
    gameResult = data.gameResult || "*";
    halfMoveClock = data.halfMoveClock || 0;
    fullMoveNumber = data.fullMoveNumber || 1;

    // Restore theme
    if (data.currentTheme) {
      currentTheme = data.currentTheme;
      const themeSelect = document.getElementById('themeSelect');
      if (themeSelect) themeSelect.value = currentTheme;
    }

    bar = data.bar || { white: 0, black: 0 };
    borneOff = data.borneOff || { white: 0, black: 0 };
    diceRoll = data.diceRoll || [];
    diceUsed = data.diceUsed || [];
    selectedPoint = data.selectedPoint ?? null;
  } else {
    hardResetForCurrentGame();
    return;
  }
  drawBoard();
  updateStatusBar();
}

function resetGame() {
  if (confirm("Do you really want to reset the game?")) {
    localStorage.removeItem(getSaveKey());
    hardResetForCurrentGame();
  }
}

function getSpriteForPiece(piece) {
  return `pieces/${currentTheme}/${piece.color}-${piece.type.toLowerCase()}.png`;
}

function updateStatusBar() {
  const statusBar = document.getElementById('statusBar');
  if (!statusBar) return;

  if (currentGame === 'chess') {
    if (gameResult !== "*") {
      if (gameResult === "1-0") {
        statusBar.textContent = "White wins! ‚ôî";
        statusBar.style.color = "#fff";
      } else if (gameResult === "0-1") {
        statusBar.textContent = "Black wins! ‚ôö";
        statusBar.style.color = "#fff";
      } else {
        statusBar.textContent = "Draw - " + gameResult;
        statusBar.style.color = "#ff0";
      }
    } else {
      const inCheck = isInCheck(currentPlayer);
      const turn = currentPlayer === 'white' ? 'White' : 'Black';
      statusBar.textContent = `${turn} to move${inCheck ? ' - CHECK!' : ''}`;
      statusBar.style.color = inCheck ? '#f00' : '#0f0';
    }
  } else if (currentGame === 'checkers') {
    statusBar.textContent = `${currentPlayer === 'white' ? 'White' : 'Black'} to move`;
    statusBar.style.color = '#0f0';
  } else if (currentGame === 'backgammon') {
    statusBar.textContent = `${currentPlayer === 'white' ? 'White' : 'Black'}'s turn`;
    statusBar.style.color = '#0f0';
  }
}

function drawBoard() {
  board.innerHTML = '';

  if (currentGame === 'backgammon') {
    document.getElementById('backgammonControls').style.display = 'block';
    document.getElementById('endTurnBtn').style.display = 'inline-block';

    board.innerHTML = '';
    board.style.display = 'flex';
    board.style.flexDirection = 'column';
    board.style.flexWrap = 'nowrap';
    board.style.alignItems = 'center';
    board.style.maxWidth = '720px';

    const topRow = document.createElement('div');
    topRow.style.display = 'flex';
    topRow.style.width = '100%';
    topRow.style.justifyContent = 'space-between';

    for (let i = 11; i >= 0; i--) {
      const point = createBackgammonPoint(i);
      topRow.appendChild(point);
    }

    const bottomRow = document.createElement('div');
    bottomRow.style.display = 'flex';
    bottomRow.style.width = '100%';
    bottomRow.style.justifyContent = 'space-between';

    for (let i = 12; i < 24; i++) {
      const point = createBackgammonPoint(i);
      bottomRow.appendChild(point);
    }

    board.appendChild(topRow);
    board.appendChild(bottomRow);

    document.getElementById('moveLog').innerHTML =
      `<strong>Backgammon Mode:</strong><br>
      White on bar: ${bar.white} | Black on bar: ${bar.black}<br>
      White borne off: ${borneOff.white} | Black borne off: ${borneOff.black}`;

    updateDiceDisplay();
    return;
  }

  document.getElementById('backgammonControls').style.display = 'none';
  document.getElementById('endTurnBtn').style.display = 'none';

  const files = ['a','b','c','d','e','f','g','h'];
  board.style.display = 'grid';
  board.style.gridTemplateColumns = 'repeat(8, 1fr)';
  board.style.aspectRatio = '1 / 1';

  // Find king positions to highlight if in check
  let whiteKingPos = null;
  let blackKingPos = null;
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = gameState[row][col];
      if (piece && piece.type === 'K') {
        if (piece.color === 'white') whiteKingPos = { row, col };
        if (piece.color === 'black') blackKingPos = { row, col };
      }
    }
  }

  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.createElement('div');
      square.className = 'square ' + ((row + col) % 2 === 0 ? 'white' : 'black');
      square.dataset.row = row;
      square.dataset.col = col;

      // Highlight king if in check
      if (currentGame === 'chess') {
        if (isInCheck('white') && whiteKingPos && whiteKingPos.row === row && whiteKingPos.col === col) {
          square.classList.add('in-check');
        }
        if (isInCheck('black') && blackKingPos && blackKingPos.row === row && blackKingPos.col === col) {
          square.classList.add('in-check');
        }
      }

      if (col === 0) {
        const rank = document.createElement('div');
        rank.className = 'rank-label';
        rank.textContent = 8 - row;
        square.appendChild(rank);
      }
      if (row === 7) {
        const file = document.createElement('div');
        file.className = 'file-label';
        file.textContent = files[col];
        square.appendChild(file);
      }

      const piece = gameState[row] ? gameState[row][col] : null;
      if (piece) {
        const img = document.createElement('img');
        if (currentGame === 'chess') {
          img.src = getSpriteForPiece(piece);
        } else if (currentGame === 'checkers') {
          const type = piece.king ? 'k' : 'p';
          img.src = `pieces/${currentTheme}/${piece.color}-${type}.png`;
        }
        square.appendChild(img);
      }

      if (selectedSquare && selectedSquare.row == row && selectedSquare.col == col) {
        square.classList.add('selected');
      }
      if (legalMoves.some(m => m.row === row && m.col === col)) {
        square.classList.add('highlight');
      }

      square.addEventListener('click', handleSquareClick);
      board.appendChild(square);
    }
  }

  const logDiv = document.getElementById('moveLog');
  if (currentGame === 'chess') {
    logDiv.innerHTML = `<strong>Move Log:</strong><br>` + pgnMoves.map((pair, i) => {
      return `${i + 1}. ${pair[0] || '...'} ${pair[1] || ''}`.trim();
    }).join('<br>');
    logDiv.scrollTop = logDiv.scrollHeight;
  } else if (currentGame === 'checkers') {
    logDiv.innerHTML = `<strong>Checkers Mode:</strong> Basic moves only (log coming soon)`;
  }
}

function handleSquareClick(e) {
  const row = parseInt(e.currentTarget.dataset.row);
  const col = parseInt(e.currentTarget.dataset.col);
  const clickedPiece = gameState[row][col];

  if (gameResult !== "*" && currentGame === 'chess') {
    return; // Game is over
  }

  if (currentGame === 'checkers') {
    if (selectedSquare) {
      if (legalMoves.some(m => m.row === row && m.col === col)) {
        const from = selectedSquare;
        const piece = gameState[from.row][from.col];
        const turnOver = makeCheckersMove(from.row, from.col, row, col, piece);

        if (turnOver) {
          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          selectedSquare = null;
          legalMoves = [];
          checkForWin();
          saveGame();
        } else {
          saveGame();
        }

        drawBoard();
        updateStatusBar();
        return;
      } else {
        selectedSquare = null;
        legalMoves = [];
        drawBoard();
        return;
      }
    } else {
      if (clickedPiece && clickedPiece.color === currentPlayer) {
        selectedSquare = { row, col };
        legalMoves = getCheckersLegalMoves(row, col, clickedPiece);
        drawBoard();
        return;
      }
    }
  }

  if (selectedSquare) {
    if (legalMoves.some(m => m.row === row && m.col === col)) {
      const from = selectedSquare;
      const piece = gameState[from.row][from.col];
      
      const wasCapture = gameState[row][col] !== null;
      const wasPawnMove = piece.type === 'P';
      
      const move = {
        fromRow: from.row,
        fromCol: from.col,
        toRow: row,
        toCol: col,
        piece,
        capture: gameState[row][col]
      };

      // Handle castling
      if (piece.type === 'K' && Math.abs(col - from.col) === 2) {
        const rookCol = col === 6 ? 7 : 0;
        const newRookCol = col === 6 ? 5 : 3;
        const rook = gameState[row][rookCol];
        gameState[row][newRookCol] = { ...rook, hasMoved: true };
        gameState[row][rookCol] = null;
        move.castle = col === 6 ? 'K' : 'Q';
      }

      // Handle en passant capture
      if (piece.type === 'P' && col !== from.col && !move.capture) {
        move.capture = gameState[from.row][col];
        move.enPassant = true;
        gameState[from.row][col] = null;
      }

      // Move the piece
      gameState[row][col] = { ...piece, hasMoved: true };
      gameState[from.row][from.col] = null;

      // Handle pawn promotion
      if (piece.type === 'P' && (row === 0 || row === 7)) {
        gameState[row][col].type = 'Q';
        move.promotion = 'Q';
      }

      // Update castling rights
      if (piece.type === 'K') {
        castlingRights[piece.color].K = false;
        castlingRights[piece.color].Q = false;
      }
      if (piece.type === 'R') {
        if (from.col === 0) castlingRights[piece.color].Q = false;
        if (from.col === 7) castlingRights[piece.color].K = false;
      }
      // If a rook is captured
      if (move.capture && move.capture.type === 'R') {
        const captureColor = move.capture.color;
        if (col === 0) castlingRights[captureColor].Q = false;
        if (col === 7) castlingRights[captureColor].K = false;
      }

      logMove(from, { row, col }, piece, move);

      // Set en passant target
      enPassantTarget = null;
      if (piece.type === 'P' && Math.abs(row - from.row) === 2) {
        enPassantTarget = { row: (row + from.row) / 2, col };
      }

      // Update halfmove clock (for 50-move rule)
      if (wasPawnMove || wasCapture) {
        halfMoveClock = 0;
      } else {
        halfMoveClock++;
      }

      // Update full move number
      if (currentPlayer === 'black') {
        fullMoveNumber++;
      }

      moveHistory.push(move);
      currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

      saveGame();
      checkForWin();
    }

    selectedSquare = null;
    legalMoves = [];
  } else {
    if (clickedPiece && clickedPiece.color === currentPlayer) {
      selectedSquare = { row, col };
      legalMoves = getLegalMoves(row, col, clickedPiece);
    }
  }

  drawBoard();
  updateStatusBar();
}

function makeCheckersMove(fromRow, fromCol, toRow, toCol, piece) {
  const move = legalMoves.find(m => m.row === toRow && m.col === toCol);

  gameState[toRow][toCol] = piece;
  gameState[fromRow][fromCol] = null;

  let captured = false;

  if (move.capture) {
    const { row: capRow, col: capCol } = move.capture;
    gameState[capRow][capCol] = null;
    captured = true;
  }

  if ((piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7)) {
    piece.king = true;
  }

  if (captured) {
    const moreJumps = getCheckersLegalMoves(toRow, toCol, piece).filter(m => m.capture);
    if (moreJumps.length > 0) {
      selectedSquare = { row: toRow, col: toCol };
      legalMoves = moreJumps;
      return false;
    }
  }

  return true;
}

function logMove(from, to, piece, moveData) {
  const files = ['a','b','c','d','e','f','g','h'];
  const fromNotation = files[from.col] + (8 - from.row);
  const toNotation = files[to.col] + (8 - to.row);
  
  let moveNotation = '';
  
  // Castling notation
  if (moveData.castle) {
    moveNotation = moveData.castle === 'K' ? 'O-O' : 'O-O-O';
  } else {
    // Piece prefix (except pawns)
    if (piece.type !== 'P') {
      moveNotation += piece.type;
    }
    
    // Capture notation
    if (moveData.capture || moveData.enPassant) {
      if (piece.type === 'P') {
        moveNotation += files[from.col];
      }
      moveNotation += 'x';
    }
    
    // Destination square
    moveNotation += toNotation;
    
    // Promotion
    if (moveData.promotion) {
      moveNotation += '=' + moveData.promotion;
    }
  }

  // Check/checkmate notation will be added in checkForWin()
  
  if (piece.color === 'white') {
    pgnMoves.push([moveNotation, '']);
  } else {
    if (pgnMoves.length === 0) pgnMoves.push(['', '']);
    pgnMoves[pgnMoves.length - 1][1] = moveNotation;
  }
}

function getCheckersLegalMoves(row, col, piece) {
  const directions = [];
  if (piece.color === 'white' || piece.king) directions.push([-1, -1], [-1, 1]);
  if (piece.color === 'black' || piece.king) directions.push([1, -1], [1, 1]);

  const moves = [];
  for (const [dr, dc] of directions) {
    const newRow = row + dr;
    const newCol = col + dc;
    const jumpRow = row + 2 * dr;
    const jumpCol = col + 2 * dc;

    if (isInBounds(newRow, newCol) && !gameState[newRow][newCol]) {
      moves.push({ row: newRow, col: newCol });
    }

    if (
      isInBounds(jumpRow, jumpCol) &&
      gameState[newRow][newCol] &&
      gameState[newRow][newCol].color !== piece.color &&
      !gameState[jumpRow][jumpCol]
    ) {
      moves.push({ row: jumpRow, col: jumpCol, capture: { row: newRow, col: newCol } });
    }
  }
  return moves;
}

function isInBounds(row, col) {
  return row >= 0 && row < 8 && col >= 0 && col < 8;
}

function getLegalMoves(row, col, piece) {
  const moves = getPseudoLegalMoves(row, col, piece);
  
  // Filter out moves that would leave own king in check
  return moves.filter(move => {
    return !wouldBeInCheckAfterMove(row, col, move.row, move.col, piece.color);
  });
}

function getPseudoLegalMoves(row, col, piece) {
  const moves = [];
  const isOnBoard = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
  const directions = {
    R: [[1,0], [-1,0], [0,1], [0,-1]],
    B: [[1,1], [1,-1], [-1,1], [-1,-1]],
    Q: [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]],
    N: [[2,1], [1,2], [-1,2], [-2,1], [-2,-1], [-1,-2], [1,-2], [2,-1]],
    K: [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]]
  };

  if (piece.type === 'P') {
    const dir = piece.color === 'white' ? -1 : 1;
    const startRow = piece.color === 'white' ? 6 : 1;

    if (isOnBoard(row + dir, col) && !gameState[row + dir][col]) {
      moves.push({ row: row + dir, col });
      if (row === startRow && !gameState[row + 2 * dir][col]) {
        moves.push({ row: row + 2 * dir, col });
      }
    }

    for (let dc of [-1, 1]) {
      const r = row + dir, c = col + dc;
      if (isOnBoard(r, c)) {
        const target = gameState[r][c];
        if (target && target.color !== piece.color) {
          moves.push({ row: r, col: c });
        } else if (enPassantTarget && enPassantTarget.row === r && enPassantTarget.col === c) {
          moves.push({ row: r, col: c });
        }
      }
    }
  } else if (piece.type === 'N' || piece.type === 'K') {
    for (let [dr, dc] of directions[piece.type]) {
      const r = row + dr, c = col + dc;
      if (isOnBoard(r, c) && (!gameState[r][c] || gameState[r][c].color !== piece.color)) {
        moves.push({ row: r, col: c });
      }
    }

    // Castling
    if (piece.type === 'K' && !piece.hasMoved && !isInCheck(piece.color)) {
      const side = piece.color;
      const rank = piece.color === 'white' ? 7 : 0;
      
      // Kingside castling
      if (castlingRights[side].K && 
          !gameState[rank][5] && 
          !gameState[rank][6] &&
          gameState[rank][7] && 
          gameState[rank][7].type === 'R' && 
          !gameState[rank][7].hasMoved &&
          !isSquareAttacked(rank, 5, piece.color) &&
          !isSquareAttacked(rank, 6, piece.color)) {
        moves.push({ row: rank, col: 6 });
      }
      
      // Queenside castling
      if (castlingRights[side].Q && 
          !gameState[rank][1] && 
          !gameState[rank][2] && 
          !gameState[rank][3] &&
          gameState[rank][0] && 
          gameState[rank][0].type === 'R' && 
          !gameState[rank][0].hasMoved &&
          !isSquareAttacked(rank, 2, piece.color) &&
          !isSquareAttacked(rank, 3, piece.color)) {
        moves.push({ row: rank, col: 2 });
      }
    }
  } else {
    for (let [dr, dc] of directions[piece.type]) {
      for (let i = 1; i < 8; i++) {
        const r = row + dr * i, c = col + dc * i;
        if (!isOnBoard(r, c)) break;
        if (!gameState[r][c]) {
          moves.push({ row: r, col: c });
        } else {
          if (gameState[r][c].color !== piece.color) {
            moves.push({ row: r, col: c });
          }
          break;
        }
      }
    }
  }
  return moves;
}

function wouldBeInCheckAfterMove(fromRow, fromCol, toRow, toCol, color) {
  // Make a temporary move
  const originalPiece = gameState[fromRow][fromCol];
  const capturedPiece = gameState[toRow][toCol];
  const enPassantCapture = originalPiece && originalPiece.type === 'P' && 
                          toCol !== fromCol && !capturedPiece &&
                          enPassantTarget && enPassantTarget.row === toRow && enPassantTarget.col === toCol
                          ? gameState[fromRow][toCol] : null;
  
  gameState[toRow][toCol] = originalPiece;
  gameState[fromRow][fromCol] = null;
  if (enPassantCapture) {
    gameState[fromRow][toCol] = null;
  }
  
  const inCheck = isInCheck(color);
  
  // Undo the move
  gameState[fromRow][fromCol] = originalPiece;
  gameState[toRow][toCol] = capturedPiece;
  if (enPassantCapture) {
    gameState[fromRow][toCol] = enPassantCapture;
  }
  
  return inCheck;
}

function isSquareAttacked(row, col, byColor) {
  const opponentColor = byColor === 'white' ? 'black' : 'white';
  
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = gameState[r][c];
      if (piece && piece.color === opponentColor) {
        const attacks = getAttackMoves(r, c, piece);
        if (attacks.some(m => m.row === row && m.col === col)) {
          return true;
        }
      }
    }
  }
  
  return false;
}

function getAttackMoves(row, col, piece) {
  // Like getPseudoLegalMoves but only actual attacks - no pawn pushes, no castling
  const moves = [];
  const isOnBoard = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;
  const directions = {
    R: [[1,0], [-1,0], [0,1], [0,-1]],
    B: [[1,1], [1,-1], [-1,1], [-1,-1]],
    Q: [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]],
    N: [[2,1], [1,2], [-1,2], [-2,1], [-2,-1], [-1,-2], [1,-2], [2,-1]],
    K: [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]]
  };

  if (piece.type === 'P') {
    // Pawns only attack diagonally
    const dir = piece.color === 'white' ? -1 : 1;
    for (let dc of [-1, 1]) {
      const r = row + dir, c = col + dc;
      if (isOnBoard(r, c)) {
        moves.push({ row: r, col: c });
      }
    }
  } else if (piece.type === 'N' || piece.type === 'K') {
    // Knights and Kings - simple moves only (no castling for king)
    for (let [dr, dc] of directions[piece.type]) {
      const r = row + dr, c = col + dc;
      if (isOnBoard(r, c)) {
        moves.push({ row: r, col: c });
      }
    }
  } else {
    // Rooks, Bishops, Queens - sliding pieces
    for (let [dr, dc] of directions[piece.type]) {
      for (let i = 1; i < 8; i++) {
        const r = row + dr * i, c = col + dc * i;
        if (!isOnBoard(r, c)) break;
        moves.push({ row: r, col: c });
        if (gameState[r][c]) break; // Stop at first piece
      }
    }
  }
  return moves;
}

function isInCheck(color) {
  let kingRow = -1, kingCol = -1;

  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = gameState[row][col];
      if (piece && piece.color === color && piece.type === 'K') {
        kingRow = row;
        kingCol = col;
        break;
      }
    }
    if (kingRow !== -1) break;
  }

  if (kingRow === -1) return false; // No king found (shouldn't happen)

  return isSquareAttacked(kingRow, kingCol, color);
}

function hasAnyLegalMoves(color) {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = gameState[row][col];
      if (piece && piece.color === color) {
        const moves = getLegalMoves(row, col, piece);
        if (moves.length > 0) return true;
      }
    }
  }
  return false;
}

function downloadPGN() {
  const pgnHeader = `[Event "Khon's Chess Match"]
[Site "Khon's Bar"]
[Date "${new Date().toISOString().split('T')[0]}"]
[Round "-"]
[White "Player 1"]
[Black "Player 2"]
[Result "${gameResult}"]

`;

  const pgnBody = pgnMoves
    .map((pair, i) => `${i + 1}. ${pair[0]}${pair[1] ? ' ' + pair[1] : ''}`)
    .join(' ');

  const fullPGN = pgnHeader + '\n' + pgnBody + ` ${gameResult}`;

  const blob = new Blob([fullPGN], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'khons-chess-game.pgn';
  a.click();
  URL.revokeObjectURL(url);
}

function changeTheme(theme) {
  currentTheme = theme;
  setURLParam('theme', theme);
  drawBoard();
  saveGame();
}

let showingQR = false;

function toggleQR() {
  const logo = document.getElementById('logoImage');
  const overlay = document.getElementById('qrOverlay');

  if (!showingQR) {
    logo.src = './khonschess-qr.png';
    overlay.style.display = 'flex';
    setTimeout(() => {
      overlay.style.display = 'none';
    }, 3000);
  } else {
    logo.src = './kclogo.png';
    overlay.style.display = 'none';
  }
  showingQR = !showingQR;
}

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js')
    .then(reg => console.log("‚úÖ Service Worker Registered"))
    .catch(err => console.warn("‚ùå Service Worker Failed:", err));
}

// Win checking
function checkForWin() {
  if (currentGame === 'chess') {
    const hasLegalMoves = hasAnyLegalMoves(currentPlayer);
    const inCheck = isInCheck(currentPlayer);
    
    if (!hasLegalMoves) {
      if (inCheck) {
        // Checkmate
        const winner = currentPlayer === 'white' ? 'black' : 'white';
        gameResult = winner === 'white' ? "1-0" : "0-1";
        
        // Add checkmate symbol to last move
        if (pgnMoves.length > 0) {
          const lastMove = pgnMoves[pgnMoves.length - 1];
          const moveIndex = currentPlayer === 'white' ? 0 : 1;
          if (lastMove[moveIndex]) {
            lastMove[moveIndex] += '#';
          }
        }
        
        saveGame();
        updateStatusBar();
        
        setTimeout(() => {
          if (confirm(`Checkmate! ${winner === 'white' ? 'White' : 'Black'} wins! üéâ Play again?`)) {
            resetGame();
          }
        }, 100);
      } else {
        // Stalemate
        gameResult = "1/2-1/2";
        saveGame();
        updateStatusBar();
        
        setTimeout(() => {
          if (confirm("Stalemate! It's a draw. Play again?")) {
            resetGame();
          }
        }, 100);
      }
    } else if (inCheck) {
      // Add check symbol to last move
      if (pgnMoves.length > 0) {
        const lastMove = pgnMoves[pgnMoves.length - 1];
        const moveIndex = currentPlayer === 'white' ? 0 : 1;
        if (lastMove[moveIndex] && !lastMove[moveIndex].endsWith('+')) {
          lastMove[moveIndex] += '+';
        }
      }
    } else if (halfMoveClock >= 100) {
      // 50-move rule (100 half-moves)
      gameResult = "1/2-1/2";
      saveGame();
      updateStatusBar();
      
      setTimeout(() => {
        if (confirm("Draw by 50-move rule! Play again?")) {
          resetGame();
        }
      }, 100);
    }
    // TODO: Add threefold repetition detection
  }

  if (currentGame === 'checkers') {
    let whiteCount = 0;
    let blackCount = 0;
    let whiteMoves = 0;
    let blackMoves = 0;

    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        const piece = gameState[row][col];
        if (!piece) continue;

        if (piece.color === 'white') {
          whiteCount++;
          whiteMoves += getCheckersLegalMoves(row, col, piece).length;
        }
        if (piece.color === 'black') {
          blackCount++;
          blackMoves += getCheckersLegalMoves(row, col, piece).length;
        }
      }
    }

    if (whiteCount === 0 || whiteMoves === 0) showGameOver('black');
    if (blackCount === 0 || blackMoves === 0) showGameOver('white');
  }
}

function showGameOver(winner) {
  gameResult = winner === 'white' ? "1-0" : "0-1";
  saveGame();
  updateStatusBar();
  setTimeout(() => {
    if (confirm(`${winner} wins! üéâ Play again?`)) {
      resetGame();
    }
  }, 100);
}

// Backgammon
document.getElementById('rollDiceBtn').addEventListener('click', () => {
  if (diceRoll.length > 0) {
    alert("You already rolled.");
    return;
  }

  const die1 = Math.ceil(Math.random() * 6);
  const die2 = Math.ceil(Math.random() * 6);

  if (die1 === die2) {
    diceRoll = [die1, die1, die1, die1];
  } else {
    diceRoll = [die1, die2];
  }
  diceUsed = [];
  updateDiceDisplay();
  saveGame();
});

document.getElementById('endTurnBtn').addEventListener('click', () => {
  if (currentGame !== 'backgammon') return;

  if (diceRoll.length === 0) {
    alert("You haven't rolled dice yet.");
    return;
  }

  const confirmEnd = confirm("‚ö†Ô∏è Are you *absolutely* sure you want to end your turn?\n\nThis could be the moment your ancestors will judge you forever.");
  if (!confirmEnd) return;

  diceRoll = [];
  diceUsed = [];
  selectedPoint = null;

  currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
  alert(`Turn over. ${currentPlayer}'s turn.`);

  updateDiceDisplay();
  drawBoard();
  updateStatusBar();
  saveGame();
});

function updateDiceDisplay() {
  if (currentGame !== 'backgammon') return;

  const display = document.getElementById('diceDisplay');
  if (diceRoll.length === 0) {
    display.textContent = "No roll yet.";
  } else {
    const unused = diceRoll.filter((d, i) => !diceUsed.includes(i));
    display.textContent = "Dice: " + unused.join(", ");
  }
}

function createBackgammonPoint(index) {
  const point = document.createElement('div');
  point.style.width = '8%';
  point.style.height = '200px';
  point.style.border = '1px solid #888';
  point.style.display = 'flex';
  point.style.flexDirection = 'column';
  point.style.justifyContent = 'flex-end';
  point.style.alignItems = 'center';
  point.style.background = (index % 2 === 0) ? '#444' : '#eee';
  point.dataset.index = index;

  const label = document.createElement('div');
  label.textContent = (index + 1);
  label.style.fontSize = '0.7em';
  label.style.opacity = '0.5';
  point.appendChild(label);

  const countWhite = gameState[index].white;
  const countBlack = gameState[index].black;

  if (countWhite > 0) {
    for (let i = 0; i < countWhite; i++) {
      const img = document.createElement('img');
      img.src = `pieces/${currentTheme}/white-p.png`;
      img.style.width = '80%';
      img.style.marginBottom = '2px';
      point.appendChild(img);
    }
  }

  if (countBlack > 0) {
    for (let i = 0; i < countBlack; i++) {
      const img = document.createElement('img');
      img.src = `pieces/${currentTheme}/black-p.png`;
      img.style.width = '80%';
      img.style.marginBottom = '2px';
      point.appendChild(img);
    }
  }

  point.addEventListener('click', handleBackgammonClick);
  return point;
}

function handleBackgammonClick(e) {
  const index = parseInt(e.currentTarget.dataset.index);
  const point = gameState[index];

  if (diceRoll.length === 0) {
    alert("Roll dice first!");
    return;
  }

  if (bar[currentPlayer] > 0) {
    const entryRange = currentPlayer === 'white' ? [18,19,20,21,22,23] : [0,1,2,3,4,5];
    if (!entryRange.includes(index)) {
      alert("You must re-enter on the opponent's home board.");
      return;
    }
    const opponentCount = point[currentPlayer === 'white' ? 'black' : 'white'];
    if (opponentCount > 1) {
      alert("Cannot re-enter here, blocked.");
      return;
    }

    const distance = currentPlayer === 'white' ? 23 - index : index;
    const dieIndex = diceRoll.findIndex((d, i) => !diceUsed.includes(i) && d === distance + 1);
    if (dieIndex === -1) {
      alert("Invalid die for re-entry.");
      return;
    }

    bar[currentPlayer]--;
    point[currentPlayer]++;
    diceUsed.push(dieIndex);

    if (diceUsed.length === diceRoll.length) {
      diceRoll = [];
      diceUsed = [];
      currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
      alert(`Turn over. ${currentPlayer}'s turn.`);
    }

    updateDiceDisplay();
    drawBoard();
    updateStatusBar();
    saveGame();
    return;
  }

  if (selectedPoint === null) {
    if (point[currentPlayer] > 0) {
      selectedPoint = index;
      highlightAvailableDestinations(index);
      saveGame();
    } else {
      alert("No pieces on this point to move.");
    }
    return;
  }

  if (index === selectedPoint) {
    selectedPoint = null;
    drawBoard();
    saveGame();
    return;
  }

  if (point[currentPlayer] > 0) {
    selectedPoint = index;
    highlightAvailableDestinations(index);
    saveGame();
    return;
  }

  const distance = getBackgammonMoveDistance(selectedPoint, index);
  const dieIndex = diceRoll.findIndex((d, i) => !diceUsed.includes(i) && d === distance);

  if (dieIndex === -1) {
    alert(`Invalid move: No die matches this distance (${distance}). You can select another checker.`);
    return;
  }

  const opponent = currentPlayer === 'white' ? 'black' : 'white';
  const opponentCount = point[opponent];

  if (opponentCount > 1) {
    alert("Cannot land here, blocked by opponent. You can select another checker.");
    return;
  }

  if (opponentCount === 1) {
    point[opponent] = 0;
    bar[opponent]++;
    alert("Hit opponent checker!");
  }

  gameState[selectedPoint][currentPlayer]--;
  gameState[index][currentPlayer]++;
  diceUsed.push(dieIndex);
  selectedPoint = null;

  if (diceUsed.length === diceRoll.length) {
    diceRoll = [];
    diceUsed = [];
    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
    alert(`Turn over. ${currentPlayer}'s turn.`);
  }

  updateDiceDisplay();
  drawBoard();
  updateStatusBar();
  saveGame();
}

function getBackgammonMoveDistance(from, to) {
  if (currentPlayer === 'white') return from - to;
  return to - from;
}

function highlightAvailableDestinations(fromIndex) {
  drawBoard();

  const allPoints = board.querySelectorAll('div[data-index]');
  allPoints.forEach(pt => {
    if (parseInt(pt.dataset.index) === fromIndex) pt.classList.add('bg-selected');
  });

  diceRoll.forEach((die, i) => {
    if (diceUsed.includes(i)) return;
    const toIndex = currentPlayer === 'white' ? fromIndex - die : fromIndex + die;
    if (toIndex >= 0 && toIndex < 24) {
      const destPoint = board.querySelector(`div[data-index="${toIndex}"]`);
      if (destPoint) destPoint.classList.add('bg-highlight');
    }
  });
}

// Game select handling
document.getElementById('gameSelect').addEventListener('change', (e) => {
  const newGame = e.target.value;
  if (newGame === currentGame) return;

  if (confirm(`Switch to ${newGame}? This will reset the board for that game.`)) {
    currentGame = newGame;
    setURLParam('game', newGame);

    // also load its save if it exists, otherwise start fresh
    const saved = localStorage.getItem(getSaveKey());
    if (saved) {
      loadGame();
    } else {
      hardResetForCurrentGame();
    }
  } else {
    e.target.value = currentGame;
  }
});

// Apply URL overrides first, then load for that game
applyGameFromURL();
applyThemeFromURL();

// Keep URL explicit if user used shorthand
setURLParam('game', currentGame);
setURLParam('theme', currentTheme);

loadGame();
</script>

<div style="margin-top: 30px; font-size: 0.9em; color: #888;">
  Version 2.7.1 (Bug Fixes: Checkers, Chess, Theme Restore, Labels)
</div>

</body>
</html>
